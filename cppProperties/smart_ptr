在C++11中新加入了两种智能指针 shared_ptr和 unique_ptr。 还有weak_ptr，这里暂时不考虑这个。

智能指针的作用，主要就是为了防止程序员在新建一个指针分配了一个内存空间后忘了释放形成的内存泄露。当然也有可能会因为异常，而未能调用delete去释放空间。所以为了防止这种情况，就设计出了智能指针，智能指针算是一个模板类，他内置了一个析构函数，所以当这个类被释放时，空间就会被释放。

之前的c++版本有一个auto_ptr.那么为什么需要新添这两个智能指针呢，因为auto_ptr有缺陷。如下

auto_ptr<int> a(new int(3));
auto_ptr<int> b;
b=a;

在这里，按照以前的指针，则b和a将会同时指向一个内存空间，但是这样是不行的。因为b和a都会尝试去删除同一个内存空间，会被删除两次。而且a在赋值的时候就会自动调用析构函数，所以这一步就会直接出现段错误。
要解决这样的方法,只有三种方法：
1.就是进行深复制，重写复制构造函数
2.更改所有权，将a的所有权直接给b。
3.创建智能更高的指针，使用引用计数来跟踪。

第二个解决方法，就体现出auto_ptr和unique_ptr的区别。
因为auto_ptr会允许a=b这种赋值，但是实际上b已经无法使用了，当你使用b时。

第三个解决方法，就是使用shared_ptr
赋值时将会让引用计数加1，调用析构函数会让引用计数减一，当引用计数为0时，使用delete释放空间。这样一个内存空间可以被多个shared_ptr指向。
