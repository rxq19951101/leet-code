本身没有系统的学习过计算机网络，在学习了TCP/IP协议后，看着unix网络编程，进行了socket网络编程的学习。


首先先理解一点，所学所有理论知识，皆为了实践而生，所以从网络编程中，我熟悉了更多TCP/IP协议以及操作系统的知识。

先设立一个框架，所有的网络编程都离不开客户端服务器的范围。
所以我写了一个服务器客户端程序，设计思路如下

	      #服务器#								    #客户端#

       建立一个socket--服务器，使用socket函数，返回一个描述符		 	建立一个socket
		  | 								       |
		  |								       |	
	       bind()--使用函数将socket与本地IP绑在一起 				       |
 		  |								       |
		  |								       |
	       listen()--作为服务器，需要监听客户端的请求         		       |
		  |	 这是一个阻塞行为					       |	
		  |								       |
	       accept()--这个函数是代表服务端和客户端已经处理 -------------------	connect()--直接使用connect函数与服务器连接
		  |	 完三次握手的过程，会返回一个描述符			       |
		  |								       |
	       close(conn)  这一步是关闭连接，close函数会完全关闭		      close()关闭连接
		  |	    全双工通道，使用shutdown()函数可以只关闭一边
		  |
	       close(listenfd)  关闭监听套接字

通过上面的步骤，可以搭建一个简单的服务器客户端连接
由于我使用的全部是阻塞I/O模型，所以一次只能连接一个。要想服务器一对多的连接，要怎么处理？（还有问题就是，如果我在使用read函数，将进程阻塞在这，而对方此时直接关闭连接，发送给我FIN，但是由于我阻塞在read中，所以我收不到。这样会）
创建新的进程
在unix环境中，使用fork()函数，可以创建一个子进程，子进程拥有自己的内存空间，但是会完全复制父进程的所有

fork函数可以返回三个值，如果返回值小于0，则代表错误。
		       如果返回值等于0,则为子进程(childpid=fork()==0){}（由于子进程继承了所有的父进程情况，在这里需要关掉监听套接字）
		       如果返回值大于0,则为父进程else
这其中你会时不时发现，在结束连接之后，会有僵尸进程，是因为子进程终止了，给父进程发了一个信号，但是这个信号被默认忽略，所以子进程没被处理，变成了僵尸进程。所以为了处理信号，我们必须调用signal()函数，这个函数第一个参数，是信号名称，第二个参数是你接受到这个信号时所运行的函数。而这个函数要怎么才能终止掉这个僵尸进程呢？这就要在函数中使用另一个函数wait()和waitpid()了，这两个函数会处理已终止（就是运行了exit()函数的进程）。但是使用wait()函数必须谨慎，因为一旦统一时间内多个信号同时传入，信号也不排队，那么wait()函数就只处理一个信号，也就是只处理了一个终止的进程，其他同时关闭的进程都还是变成了僵尸进程。这里就要使用waitpid()了，反正就是不阻塞，循环使用，具体的我也没看明白。

问题还是来了，如果每一个客户端都让服务器新建一个进程，那客户端一多起来，服务器不得爆炸？
所以这种情况下，我们就得使用复用I/O模型。这是什么意思？
复用I/O模型就是，我在一段时间内，对每一个文件描述符，进行访问，如果这个描述符就绪，就进行相应的操作。
复用I/O模型一共有三个函数select,poll,epoll
1).select函数作为最古老的函数，其使用非常复杂，第一.所访问的文件数量是有限制的，默认为2048。第二.访问的输入与结构需要构造两个结构来存储，非常不方便，怎么说呢，也就是说，你使用的时候你得将建立一个描述符集来作为输入，告诉这个函数，你想要让确认这些描述符的状态，但是你必须还要构造一个数组来存储这些描述符的空间。这样既增加了空间利用，又非常的不方便使用。
2).然后过了14年后，就出现了poll函数。poll函数就方便多了，poll的描述符集具有对输入和输出有两个成员，所以一旦建立了pollfd的描述符，就不需要自己在建立一个array来保存状态数据了。其次，他没有最大访问数量的限制。其余的均与select函数类似
3).然后linux就有了更厉害的epoll，如果使用select和poll这些，都是一个一个循环访问，你说一个两个还好，万一我有成千上万上万个，这样的话效率又低，又浪费资源。而epoll就是通过把哪个流发生了什么直接通知（你可以理解成信号），这样我们直接去处理对应的描述符，就简单多了。
这三个总的来说都算是同步IO，为什么呢？因为你始终得等到别人来数据了，你去处理数据(就是别人打电话，你始终得去接了电话你才知道对方想告诉你是什么，你们两得同时到位)。而异步IO是（举个例子：别人给你发了个短信，他也不管你收不收得到，你也不需要及时看，等你想起来了，想要看一下这些数据，你就直接查一下短信就行了），你直接运行一个函数，然后到时直接得到了处理数据之后的结果。一句两句说不清楚，不行可以去看我的IO模型介绍。

初步网络编程就学了这些，至于里面用到的tcp三次握手，四次分手，建立连接时客户端与服务器各个时间段的状态这些基础知识，另写一篇文档。


