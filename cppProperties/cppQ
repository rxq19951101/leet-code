1. new delete malloc free的关系

new/delete 会调用构造函数和析构函数，而malloc和free是库函数需要头文件支持，new/delete是运算符或者是关键字，需要编译器支持。他们都可以动态分配空间。

new返回的是对象类型的指针。而malloc分配成功后返回的是void*，需要通过强制转换才能将void指针转换成我们需要的类型。

如果内存分配失败，new会抛出bac_alloc异常。而malloc会返回NULL。

new不需要制定内存块大小，编译器会根据类型自行计算。而malloc则需要指出所需内存的尺寸。

使用new[]分配数组，则就必须使用delete[]去释放。而malloc没有建造数组的概念，如果需要分配数组需要自行定义内存空间大小。

分配空间类型。new分配的是自由存储区。这个自由存储区既可以是堆也可以是静态存储区。而malloc是分配的堆

delete 只会调用一个析构函数，而delete[]会调用多个析构函数

c++的三大特性：
封装：数据和代码捆绑在一起，避免外界的干扰和不确定访问。
继承：让某种类型对象获得另一个类型对象的属性和方法。
多态：多个接口，同一个事物表现出不同事物的能力。

多态实际上就是多种接口：分为静态多态和动态动态，静态多态就是在编译的时候决定，而动态多态就是在运行中决定。重载为静态，而虚函数是动态多态。

2.引用和指针的区别
a.指针是一个实体，它的内容是指向另一个内存地址。而引用只是一个别名。

b.引用不能为空，而指针可以为空。

c.引用必须初始化，而且只能定义一次。而指针可以不被初始化，且能多次定义。

3.const和define的区别
const是定义一个常量，要分配内存，需要定义类型。define没有数据类型，不分配内存，有多少次使用就进行多少次替换。需要注意define的边缘消效应。const是存储在静态存储区的，只有只读操作。
define是在预处理时进行替换。而const是在编译的时候确定其值

4.static
静态成员变量，不可以定义在类中，需要类外进行定义。而且静态成员变量不能在析构函数中进行初始化，因为不同类中使用的这个变量都是在同一个内存中。在超出函数作用域时，const的内存就会被释放，而static不会。

5.拷贝构造函数
拷贝构造函数在构造函数中如果有动态分配空间时需要特别注意。一般的拷贝，如果里面有指针，则只赋值指针的内容但不重新分配一个新的空间，这会造成问题，因为当你拷贝时，另一个类将会在这时调用析构函数，如果把这个空间给释放了，则拷贝的就会是一个空指针。这就是浅拷贝。而深拷贝的话，构造函数中如果包含动态分配空间，则拷贝时会自己重新分配一个内存来存储。

6.构造函数和析构函数能否为虚函数
构造函数不能定义为虚函数，而且不能调用虚函数，因为在构造时，调用的将会是父类的虚函数，自己的还没有构造好。而析构函数大部分都为虚函数，因为如果不是虚函数的话，派生类将会调用父类的析构函数。
