IO 复用
在了解IO复用之前，先了解IO的5个模型

一.阻塞I/O
这种I/O模型是必须等待操作执行顺利的情况下才能返回。
比如Read，如果没有数据的情况下，将一直阻塞在read这里，无法进行下一步操作
而我们的线程以及进程都是线性关系，必须一步一步走，这一步阻塞了。程序就卡在这里了。

二.非阻塞I/O
这种I/O模型就非常的简单粗暴，同样使用read，如果缓存区内没有数据，直接返回错误。
然后接着进行下一步操作

三.I/O复用
这种I/O模型就是我们经常使用的。在unix下一共有三个函数可以使用I/O复用，select,poll,epoll。这三种的使用以及区别下次再说。不过中心思想就是，轮番问，放入一堆操作的描述符，然后对每个描述符进行询问，查看buffer区是否有内容可读，如果有则进行read操作，如果在一段时间内没有，就直接询问下一个，然后一直循环。这样就可以在一个线程的情况下对不同情况进行处理。可以节省空间以及cpu资源，因为线程进程的上下文转换，都会消耗cpu资源。

四.信号驱动IO模型）
跟第三种很相似，不过使用了信号，即缓存区东西准备好了，系统信号中断，让他去处理这个缓存区。

五.异步IO
这个就是IO直接发起一个操作，进程直接返回，但不返回结果，内核把read这个功能处理完了，直接给你一个read的结果。直接得到数据。
