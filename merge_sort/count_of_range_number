难度：HARD

Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.
Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.

Note:
A naive algorithm of O(n2) is trivial. You MUST do better than that.
Example:

Input: nums = [-2,5,-1], lower = -2, upper = 2,
Output: 3 
Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.


如题，这道题做了非常的久，第一难度很大，不清楚怎么做
在看到这道题的第一思路，是快慢指针，但是由于限制了时间复杂度，所以无法解决
直接看答案。  
答案使用的是归并算法，正好这里复习一下归并排序
在这道题磨蹭了非常久的主要原因是，我能理解需要归并的作用，但一直没摸清为什么需要排序。
后来明白，排序可以极大加快效率。避免重复的比较。
举例： [2,4,10,-3]  在区间[-4,4]中
就为sum[2,6,16,13]   归并先区分成最小分组，即[2,6]和[13,16]
这里后面这个数组如果排序了，就可以发现，后面数组的最小值减去前面这个数组的最小值，如果这个值依然大于upper_bond，那么后面数组其余的数字就没有必要再去比较，因为不可能更小。
代码如下
class Solution {
private:    
    int mergeSort(vector<long long>&sum, int left, int right, int lower, int upper)
    {
        int mid, i, res, j, k;
        if(left>right) return 0;
        if(left==right) return ( (sum[left]>=lower) && (sum[left]<=upper) )?1:0;
        else
        {
            vector<long long> temp(right-left+1,0);
            mid = (left+right)/2;
            res = mergeSort(sum, left,mid, lower, upper) + mergeSort(sum, mid+1,right, lower, upper); // merge sort two halfs first, be careful about how to divide [left, mid] and [mid+1, right]
            for(i=left, j=k=mid+1; i<=mid; ++i)
            { // count the valid ranges [i,j], where i is in the first half and j is in the second half
                while(j<=right && sum[j]-sum[i]<lower)  ++j;
                while(k<=right && sum[k]-sum[i]<=upper) ++k;
                res +=k-j;
            }
            for(i=k=left, j=mid+1; k<=right; ++k) //merge the sorted two halfs
                temp[k-left] = (i<=mid) && (j>right || sum[i]<sum[j])?sum[i++]:sum[j++]; 
            for(k=left; k<=right; ++k) // copy the sorted results back to sum
                sum[k] = temp[k-left]; 
            return res;
        }
    }
public:
    int countRangeSum(vector<int>& nums, int lower, int upper) {
         int len = nums.size(), i;
         vector<long long> sum(len+1, 0);
         for(i=1; i<=len; ++i) sum[i] = sum[i-1]+nums[i-1];
         return mergeSort(sum, 1, len, lower, upper);
    }
};
