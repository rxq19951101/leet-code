迭代器


关于迭代器，网上的讨论的很多，我看了好多博客也还是没有能够看懂，所以之前一直糊里糊涂完全不知道是什么。直到看到了C++ PRIMER PLUS上的讲解，才有所明白。

想清楚什么是迭代器，必须得知道什么是容器。容器我们都知道吧，STL里：vector,queue,deque,list都是容器，这些容器就是以不同数据结构来保存数据。比如vector，虽然vector的内存都是动态分布的，但是这个容器是连续的。你可能不信，要是是连续的，万一我分布的值大于vector的容量了怎么办？这时候vector会分配两倍于自己size的一个空间，然后将之前容器所有的值都复制到新分配的空间中，所以依然还是连续的。而list则是通过链表的形式保存数据，学过数据结构的肯定知道，链表的内存都是分散的。好，这里对容器有了一个比较基本的认识后，我们来看迭代器。你容器里保存了值，可是要怎么访问呢？你肯定就会说，就以数组访问数据的形式直接访问比如vector，道理是没错。可你以为这样的访问形式是凭空来的吗？不是，这就是迭代器的其中一个作用。
举个例子，我新建一个数组int a[10];
这个数组里面的数值我们可以通过以a[0],a[1]这样的形式来进行访问。
但是同样的我们也可以使用*a来访问a[0]，*(a+1)来访问a[1]。这个大家都是知道的吧，不知道去网上查。
这就是因为数组的本质就是一串指针，我们访问数组里的值其实就是在访问指针里的值。
迭代器也一样，迭代器也叫做广义指针
vector<int> a(5,2);
vector<int>::iterator it;
it= a.begin();
cout<<*it;  
这样输出后的值就为2了。看了这个代码，应该就可以明白迭代器的作用了。
你这时候可能会想到vector可以用 a[1]这样数组的形式来表示，为什么list不行？
这里就是因为迭代器的类型不同有着不同的功能，迭代器有着五种基本类型，输入迭代器，输出迭代器，正向迭代器，双向迭代器以及随机访问迭代器
看到这五个迭代器你可能就蒙蔽了，这都是啥，不用急，很简单。
输入迭代器你可以就理解成这个迭代器只能读数据，就相当于你读我这篇文章，我可以往你脑子输入数据，你能读但你不能写。
而输出迭代器就相反，只能写不能读，可能会很意外，能写还不能读了？这其实跟我们的键盘的输入类似，你把字打出来了，将数据写在了屏幕上，可电脑能读这个数据么，不能，读的人是你。
正向迭代器就很简单，可读可写只能前进，就像单向链表一样。
双向迭代器也是，类似双向链表。
而随机访问迭代器，就是我不做任何操作的情况下，可以直接拿到我想要的数据。
从这五种类型，你不难发现，正向和双向迭代器包括了输入和输出迭代器的所有功能，而随机访问迭代器包含所有迭代器的功能。你玩我呢？讲这么多，我直接用随机访问迭代器不就行了？ 的确如此，如果你只考虑你的需求的话，这样是没错，但是需求是需要资源来提供的呀。就比如说我的list也设计成随机访问迭代器，虽然你用着是爽，但是你每任意提取一个数据，都是通过链表进行一次遍历得来的，这样太不友好了。所以，尽可能的使用级别最低的迭代器。而我们算法的设计，也是尽可能的设计能适用与级别最低的迭代器。比如find()能用在输入迭代器中（只读），那么就能用到正向，双向和随机访问的迭代器中。反之则不行。
所以在给每一个容器设计迭代器的时候，就得考虑他们的数据结构，这样能够让你在消耗最低资源的情况下，访问到你最想要的数据。这也是为什么list没有随机访问。
而迭代器有时是会失效的，我看网上的人都是说失效，而我则认为这不是迭代器失效，只是错误的使用了。
所谓的迭代器失效，就是当你删除了一个其中一个元素，或插入一个元素，会导致后面的元素都向后靠或者向前靠。没有举例的阐述就是装逼
这里举例。
vector<int> s;//在这个容器中放入1，2,3,4,5
for(int i=1;i<6;i++) s.push_back(i);
vector<int>::iterator it;
it=s.begin();
for(;it!=s.end();it++)
{
  cout<<*it<<endl;
  if(i==3) s.erase(it);
}

讲道理如果迭代器处于正常的情况下，是不是该输出1,2,3,4,5输出，但是实际运行发现，输出的是1，2,3,5。
那为什么呢？为什么我遍历一遍没有输出里面所有的数据？这就是迭代器失效。
在erase()这个函数运行的时候将原先的s[0]删除了  s[0]-1 s[1]-2 s[2]-3 s[3]-4 s[4]-5， 但是这个删除了之后这个vector不是变成了s[1]-2 s[2]-3 s[3]-4 s[4]-5这样的形式，而是将所有在后面数据前移，删除之后就变成 s[0]-2 s[1]-3 s[2]-4 s[3]-5 而此时it++让这个迭代器去删除了后面的这个容器，即现在这个数组中的s[1]-3，就变成了s[0]-2 s[2]-4 s[3]-5而这里的2就永远擦除不掉了。这就是迭代器失效，而想解决也很简单。
在 if里加入一个it-- 就可以了。

